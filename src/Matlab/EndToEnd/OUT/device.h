// DHW method For nrf52_298644 only
#ifndef ECCLESS_H_
#define ECCLESS_H_
#include <stdint.h>
#include <string.h>
#include <stdlib.h>

#define MASK_ADDR_0 0x20004014
#define WORD_SZ 32
#define WORD_Bytes 4
#define GROUP_SZ 8
#define DELTA 6
const uint32_t Mask_first[128] = {
	0x0000, 0x000C, 0x0024, 0x001C, 0x0020, 0x0020, 0x002C, 0x0018, 
	0x0024, 0x002C, 0x000C, 0x0020, 0x0024, 0x001C, 0x002C, 0x0014, 
	0x0028, 0x002C, 0x0018, 0x001C, 0x0024, 0x0024, 0x0010, 0x0028, 
	0x0020, 0x0028, 0x0024, 0x0010, 0x001C, 0x002C, 0x0018, 0x0020, 
	0x001C, 0x002C, 0x001C, 0x0020, 0x001C, 0x001C, 0x0020, 0x0034, 
	0x0020, 0x0018, 0x0024, 0x0018, 0x0018, 0x0020, 0x0024, 0x0020, 
	0x0024, 0x0024, 0x0014, 0x0028, 0x0020, 0x0028, 0x0024, 0x0010, 
	0x0028, 0x0018, 0x001C, 0x0024, 0x0028, 0x0020, 0x0018, 0x0020, 
	0x0028, 0x0028, 0x0034, 0x0020, 0x0020, 0x001C, 0x0028, 0x0014, 
	0x002C, 0x0020, 0x0020, 0x0024, 0x0010, 0x002C, 0x0020, 0x0020, 
	0x0028, 0x001C, 0x001C, 0x0028, 0x000C, 0x002C, 0x0028, 0x0020, 
	0x0018, 0x0014, 0x0028, 0x0024, 0x0014, 0x002C, 0x0024, 0x0010, 
	0x0024, 0x0024, 0x0020, 0x0018, 0x0030, 0x001C, 0x0018, 0x0020, 
	0x0024, 0x0020, 0x0024, 0x0028, 0x000C, 0x002C, 0x0014, 0x0020, 
	0x002C, 0x0018, 0x002C, 0x0010, 0x002C, 0x001C, 0x0028, 0x0014, 
	0x002C, 0x0010, 0x0020, 0x0028, 0x0024, 0x0018, 0x002C, 0x0010}; 

	
const uint32_t Mask_second[128] = {
	0x0004, 0x001C, 0x0024, 0x000C, 0x0020, 0x0020, 0x0034, 0x0010, 
	0x002C, 0x0024, 0x0014, 0x0020, 0x002C, 0x0014, 0x002C, 0x0014, 
	0x0020, 0x002C, 0x0018, 0x0024, 0x0024, 0x001C, 0x0018, 0x0020, 
	0x0020, 0x0028, 0x0024, 0x0018, 0x0024, 0x001C, 0x0028, 0x0020, 
	0x000C, 0x0034, 0x001C, 0x0018, 0x0024, 0x0024, 0x0020, 0x0024, 
	0x0020, 0x0020, 0x001C, 0x0018, 0x0018, 0x0028, 0x002C, 0x0018, 
	0x0024, 0x0024, 0x001C, 0x0020, 0x0018, 0x0028, 0x0024, 0x0018, 
	0x0028, 0x0020, 0x000C, 0x0034, 0x0020, 0x0020, 0x0020, 0x0014, 
	0x002C, 0x0020, 0x003C, 0x0018, 0x0020, 0x0024, 0x0020, 0x001C, 
	0x0024, 0x0020, 0x0028, 0x001C, 0x0020, 0x001C, 0x0020, 0x0028, 
	0x0020, 0x001C, 0x001C, 0x0028, 0x000C, 0x002C, 0x0028, 0x0020, 
	0x0020, 0x0014, 0x0028, 0x001C, 0x0014, 0x0034, 0x001C, 0x0020, 
	0x001C, 0x001C, 0x0020, 0x0028, 0x0020, 0x0024, 0x0020, 0x0020, 
	0x001C, 0x0018, 0x002C, 0x0020, 0x001C, 0x0024, 0x0014, 0x0020, 
	0x0024, 0x0018, 0x002C, 0x0018, 0x0024, 0x001C, 0x0028, 0x001C, 
	0x0024, 0x0020, 0x0020, 0x0018, 0x002C, 0x001C, 0x0024, 0x000C}; 

	
const uint8_t u[16] = {0xD7, 0x7B, 0x7F, 0xE2, 0x28, 0xA2, 0x62, 0xDB, 0x76, 0x28, 0x2F, 0x98, 0x8A, 0xE9, 0x9F, 0x70}; 

/* Function to get no of set bits in binary
representation of positive integer n */
uint8_t countSetBits(uint8_t* pn, uint8_t bytes) {
	uint8_t *poperate_0 = (uint8_t*)malloc(bytes);
	uint8_t *poperate = poperate_0;
	memcpy(poperate,pn,bytes); //make a copy, don't wanna destroy the original memory
	uint8_t count = 0;
	while (bytes){
		while (*poperate) {
			count += *poperate & 1;
			*poperate >>= 1;
		}
		bytes --;
		poperate ++;
	}
	free(poperate_0);
	return count;
}

/*
* get reformmed PUF key form the SRAM
* Para@0 e (uint8_t*), pointer to receive key, at least 16 bytes long
* Rtn@0 Valid_bits int, number of valid key bits
*/
int getPUF(uint8_t* e){
	uint8_t e_generated[16]; // buffer for e while generating
	memset(e_generated,0,16); //initialize e buffer
	uint8_t idx; // index for the i^th e bit
	uint8_t *paddrFirst = (uint8_t *)MASK_ADDR_0; // pointer to the -first- memory location in a group
	uint8_t *paddrSecond = (uint8_t *)MASK_ADDR_0; // ..to the second
	int8_t dhw; // differential hamming weight in this group notice negative
	for(idx = 0; idx < 128; idx++){
		if((Mask_first[idx] > 0 && Mask_second[idx] > 0) || (idx == 0)){ // prevent manipulated mask, e.g. all zero offsets, idx == 0 is a special case, the offset is 0 in respect to the ¡¤MASK_ADDR_0
			paddrFirst += Mask_first[idx];
			paddrSecond += Mask_second[idx];
			dhw = countSetBits(paddrFirst,WORD_Bytes) - countSetBits(paddrSecond,WORD_Bytes);
			if(dhw >= 0){ // Max is at the lower address
				e_generated[idx/8] |= 1 << (idx%8); 
			}else{
				e_generated[idx/8] |= 0 << (idx%8); 
			}
		}else{
			return idx; // invalid mask (zero offset)
		}
	}
	memcpy(e,e_generated,16);
	return 128;
}
#endif /* ECCLESS_H_ */
