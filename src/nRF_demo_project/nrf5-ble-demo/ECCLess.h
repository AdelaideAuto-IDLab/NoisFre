// DHW method For nrf52_298641 only
#ifndef ECCLESS_H_
#define ECCLESS_H_
#include <stdint.h>
#include <string.h>
#include <stdlib.h>

#define MASK_ADDR_0 0x20004030
#define WORD_SZ 32
#define WORD_Bytes 4
#define GROUP_SZ 16
#define DELTA 16
const uint32_t Mask_first[128] = {
	0x0000, 0x0058, 0x0044, 0x0030, 0x0044, 0x0044, 0x0060, 0x0090, 
	0x002C, 0x006C, 0x001C, 0x0040, 0x00BC, 0x007C, 0x0040, 0x0040, 
	0x0068, 0x00A4, 0x00B4, 0x0048, 0x0098, 0x002C, 0x0034, 0x0090, 
	0x0034, 0x004C, 0x0030, 0x0040, 0x0064, 0x0020, 0x0058, 0x0044, 
	0x0054, 0x0038, 0x005C, 0x003C, 0x0054, 0x0044, 0x003C, 0x008C, 
	0x005C, 0x0040, 0x0054, 0x004C, 0x0030, 0x0044, 0x004C, 0x0020, 
	0x0070, 0x0014, 0x0090, 0x0048, 0x00F0, 0x0040, 0x0078, 0x0090, 
	0x002C, 0x0058, 0x0084, 0x002C, 0x0038, 0x004C, 0x0040, 0x0050, 
	0x0074, 0x0034, 0x0048, 0x009C, 0x0078, 0x004C, 0x0044, 0x0054, 
	0x009C, 0x0024, 0x004C, 0x003C, 0x0064, 0x0024, 0x0098, 0x002C, 
	0x004C, 0x0030, 0x0098, 0x0068, 0x008C, 0x0088, 0x0048, 0x0044, 
	0x00A0, 0x0058, 0x0020, 0x0084, 0x0030, 0x0068, 0x0018, 0x0048, 
	0x0064, 0x0040, 0x0040, 0x002C, 0x0038, 0x0040, 0x0044, 0x0038, 
	0x0038, 0x003C, 0x0068, 0x0070, 0x0034, 0x003C, 0x0048, 0x0048, 
	0x0038, 0x0044, 0x0110, 0x0030, 0x0078, 0x0054, 0x0028, 0x0048, 
	0x00C4, 0x007C, 0x0040, 0x0038, 0x0040, 0x0078, 0x0050, 0x015C}; 

	
const uint32_t Mask_second[128] = {
	0x0004, 0x0060, 0x0044, 0x0038, 0x0034, 0x004C, 0x0060, 0x00A0, 
	0x0044, 0x003C, 0x0044, 0x0040, 0x00AC, 0x0094, 0x0020, 0x0060, 
	0x0038, 0x00BC, 0x009C, 0x0050, 0x0098, 0x002C, 0x005C, 0x0070, 
	0x0034, 0x004C, 0x0048, 0x0038, 0x004C, 0x0030, 0x0048, 0x004C, 
	0x0044, 0x0040, 0x006C, 0x0034, 0x004C, 0x003C, 0x0044, 0x0084, 
	0x0084, 0x0028, 0x004C, 0x0054, 0x0030, 0x003C, 0x0054, 0x0038, 
	0x0048, 0x001C, 0x0090, 0x0058, 0x00E8, 0x0050, 0x0078, 0x0088, 
	0x0024, 0x0060, 0x0074, 0x004C, 0x0040, 0x002C, 0x0048, 0x0040, 
	0x006C, 0x0064, 0x0040, 0x0074, 0x0078, 0x004C, 0x0044, 0x006C, 
	0x008C, 0x001C, 0x004C, 0x004C, 0x0054, 0x0034, 0x0090, 0x002C, 
	0x0044, 0x0048, 0x0080, 0x0080, 0x007C, 0x0088, 0x0040, 0x0044, 
	0x00B0, 0x0048, 0x0030, 0x0084, 0x0038, 0x0050, 0x0048, 0x0028, 
	0x0054, 0x0040, 0x0048, 0x0024, 0x0058, 0x0030, 0x0034, 0x0040, 
	0x0038, 0x003C, 0x0060, 0x0080, 0x0034, 0x002C, 0x0068, 0x0028, 
	0x0058, 0x0024, 0x0118, 0x0038, 0x0068, 0x005C, 0x0040, 0x0028, 
	0x00D4, 0x0084, 0x0048, 0x0018, 0x0068, 0x0068, 0x0058, 0x0144}; 

	
const uint8_t u[16] = {0x12, 0xB5, 0x64, 0xE4, 0x89, 0x9E, 0xB8, 0xEB, 0x85, 0x42, 0x81, 0xA8, 0xB4, 0x08, 0x4E, 0xA0}; 

///* Function to get no of set bits in binary
//representation of positive integer n */
//uint8_t countSetBits(uint8_t* pn, uint8_t bytes) {
//	uint8_t *poperate_0 = (uint8_t*)malloc(bytes);
//	uint8_t *poperate = poperate_0;
//	memcpy(poperate,pn,bytes); //make a copy, don't wanna destroy the original memory
//	uint8_t count = 0;
//	while (bytes){
//		while (*poperate) {
//			count += *poperate & 1;
//			*poperate >>= 1;
//		}
//		bytes --;
//		poperate ++;
//	}
//	free(poperate_0);
//	return count;
//}
const unsigned TEST_BITS = 4 * 8;
uint32_t countSetBits(uint8_t* pn, uint8_t bytes) {
	uint32_t m;
	uint32_t n;
	memcpy(&n,pn,bytes);
	for(unsigned m = 0; (1u << m) < TEST_BITS; ++m)
    {
        uint32_t divisor = ((uint32_t)1 << (1u << m)) + 1; // 3,5,17,257,...
        uint32_t mask = (~(uint32_t)0) / divisor;

        n = (n & mask) + ((n >> (1u << m)) & mask);
    }
    return n;
}

/*
* get reformmed PUF key form the SRAM
* Para@0 e (uint8_t*), pointer to receive key, at least 16 bytes long
* Rtn@0 Valid_bits int, number of valid key bits
*/
int getPUF(uint8_t* e){
	uint8_t e_generated[16]; // buffer for e while generating
	memset(e_generated,0,16); //initialize e buffer
	uint8_t idx; // index for the i^th e bit
	uint8_t *paddrFirst = (uint8_t *)MASK_ADDR_0; // pointer to the -first- memory location in a group
	uint8_t *paddrSecond = (uint8_t *)MASK_ADDR_0; // ..to the second
	int8_t dhw; // differential hamming weight in this group notice negative
	for(idx = 0; idx < 128; idx++){
		if((Mask_first[idx] > 0 && Mask_second[idx] > 0) || (idx == 0)){ // prevent manipulated mask, e.g. all zero offsets, idx == 0 is a special case, the offset is 0 in respect to the ·MASK_ADDR_0
			paddrFirst += Mask_first[idx];
			paddrSecond += Mask_second[idx];
			dhw = countSetBits(paddrFirst,WORD_Bytes) - countSetBits(paddrSecond,WORD_Bytes);
			if(dhw >= 0){ // Max is at the lower address
				e_generated[idx/8] |= 1 << (idx%8); 
			}else{
				e_generated[idx/8] |= 0 << (idx%8); 
			}
		}else{
			return idx; // invalid mask (zero offset)
		}
	}
	memcpy(e,e_generated,16);
	return 128;
}
#endif /* ECCLESS_H_ */
